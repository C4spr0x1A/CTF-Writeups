# Robust PRNG in Python? - Cryptography Challenge

*   **CTF:** Junior.Crypt.2025
*   **Challenge:** Robust PRNG in Python?
*   **Category:** Cryptography

---

### The Challenge

This was another challenge targeting Python's `random` module, but with a clever twist. The server provided random numbers generated by `random.getrandbits(31)`. The standard Mersenne Twister (MT19937) algorithm, which Python uses, operates on a 32-bit state. This meant I was getting incomplete information, and standard MT19937 prediction tools wouldn't work out of the box.

### The Solution

My first step was to figure out how `getrandbits(31)` relates to the underlying 32-bit generator. A simple local test showed that `getrandbits(31)` is just the result of `getrandbits(32) >> 1`. This means I was seeing the 31 most significant bits of each random number, and only the least significant bit (LSB) was missing.

The attack plan was as follows:
1.  Collect 624 of the 31-bit random numbers from the server.
2.  For each of these numbers, I had to guess the missing LSB. This creates two possibilities for the original 32-bit number: `(num << 1) | 0` and `(num << 1) | 1`.
3.  I needed a modified MT19937 predictor that could handle this ambiguity. I would feed the two possible 32-bit values for each of the 624 numbers into the state recovery algorithm. By testing which sequence of LSBs (0s or 1s) produced a valid prediction, I could clone the server's PRNG state.
4.  Once the state was cloned, predicting the next number was straightforward.

Through local testing, I found that assuming the missing LSB was always `1` worked consistently, which simplified the final exploit script significantly.

Here is the script that connects to the server, collects the numbers, and uses a custom predictor to find the flag:

```python
# This script uses a custom MT19937Predictor31 class, which is a modified
# version of a standard predictor, built to handle the 31-bit input.
# The class itself is omitted for brevity.

import socket
import re
import time
from mt19937predictor_31bit import MT19937Predictor31 # Custom predictor

def solve_robust_prng():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect(('ctf.mf.grsu.by', 9045))
        
        # Consume the initial banner
        s.recv(1024)
        
        numbers = []
        predictor = MT19937Predictor31()

        print("[*] Collecting 624 numbers...")
        for _ in range(624):
            s.sendall(b'1\n')
            response = s.recv(1024).decode()
            num = int(re.search(r'(\d+)', response).group(1))
            # Feed the number into our custom predictor, assuming LSB is 1
            predictor.add_31bit_value(num, lsb=1)

        print("[*] Predicting next number...")
        prediction = predictor.predict_next_31bit()

        # Submit the prediction
        s.sendall(b'2\n')
        s.recv(1024) # Consume prompt
        s.sendall(f"{prediction}\n".encode())

        # Get the flag
        flag_response = s.recv(2048).decode()
        flag = re.search(r'grodno{.*?}', flag_response).group(0)
        print(f"\n[!] Flag: {flag}")

if __name__ == "__main__":
    solve_robust_prng()

```

### The Flag

The server confirmed the prediction was correct and returned the flag:

```
grodno{0dfbb057543753644953923237233143568f7edf}
```

---

*Written by Mohamed Armaoui (C4spr0x1A)*